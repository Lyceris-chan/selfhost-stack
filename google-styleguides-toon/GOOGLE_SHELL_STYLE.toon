title styleguide | Style guides for Google-originated open-source projects
section styleguide
section Shell Style Guide
    Authored, revised and maintained by many Googlers.
  section Table of Contents
        code [… ]
        code [[… ]]
  section Background
    section Which Shell to Use
    Bash is the only shell scripting language permitted for executables.
    Executables must start with#!/bin/bashand minimal flags. Usesetto set shell options so that calling your script asbash script_namedoes not break its functionality.
    Restricting all executable shell scripts tobashgives us a consistent shell language that’s installed on all our machines. In particular, this means there is generally no need to strive for POSIX-compatibility or otherwise avoid “bashisms”.
    The only exception to the above is where you’re forced to by whatever you’re coding for. For example some legacy operating systems or constrained execution environments may require plain Bourne shell for certain scripts.
    section When to use Shell
    Shell should only be used for small utilities or simple wrapper scripts.
    While shell scripting isn’t a development language, it is used for writing various utility scripts throughout Google. This style guide is more a recognition of its use rather than a suggestion that it be used for widespread deployment.
    Some guidelines:
      - If you’re mostly calling other utilities and are doing relatively little data manipulation, shell is an acceptable choice for the task.
      - If performance matters, use something other than shell.
      - If you are writing a script that is more than 100 lines long, or that uses non-straightforward control flow logic, you should rewrite it in a more structured languagenow. Bear in mind that scripts grow. Rewrite your script early to avoid a more time-consuming rewrite at a later date.
      - When assessing the complexity of your code (e.g. to decide whether to switch languages) consider whether the code is easily maintainable by people other than its author.
  section Shell Files and Interpreter Invocation
    section File Extensions
    Executables should have a.shextension or no extension.
      - If the executable will have a build rule that renames the source file then prefer to use a.shextension. This enables you to use the recommended naming convention, with a source file likefoo.shand a build rule namedfoo.
      - If the executable will be added directly to the user’sPATH, then prefer to use no extension. It is not necessary to know what language a program is written in when executing it and shell doesn’t require an extension so we prefer not to use one for executables that will be directly invoked by users. At the same time, consider whether it is preferable to deploy the output of a build rule rather than deploying the source file directly.
      - If neither of the above apply, then either choice is acceptable.
    Libraries must have a.shextension and should not be executable.
    section SUID/SGID
    SUID and SGID areforbiddenon shell scripts.
    There are too many security issues with shell that make it nearly impossible to secure sufficiently to allow SUID/SGID. While bash does make it difficult to run SUID, it’s still possible on some platforms which is why we’re being explicit about banning it.
    Usesudoto provide elevated access if you need it.
  section Environment
    section STDOUT vs STDERR
    All error messages should go toSTDERR.
    This makes it easier to separate normal status from actual issues.
    A function to print out error messages along with other status information is recommended.
        code err(){echo"[$(date+'%Y-%m-%dT%H:%M:%S%z')]:$*">&2}if!do_something;thenerr"Unable to do_something"exit1fi
  section Comments
    section File Header
    Start each file with a description of its contents.
    Every file must have a top-level comment including a brief overview of its contents. A copyright notice and author information are optional.
    Example:
        code #!/bin/bash## Perform hot backups of Oracle databases.
    section Function Comments
    Any function that is not both obvious and short must have a function header comment. Any function in a library must have a function header comment regardless of length or complexity.
    It should be possible for someone else to learn how to use your program or to use a function in your library by reading the comments (and self-help, if provided) without reading the code.
    All function header comments should describe the intended API behaviour using:
      - Description of the function.
      - Globals: List of global variables used and modified.
      - Arguments: Arguments taken.
      - Outputs: Output to STDOUT or STDERR.
      - Returns: Returned values other than the default exit status of the last command run.
    Example:
        code ######################################## Cleanup files from the backup directory.# Globals:#   BACKUP_DIR#   ORACLE_SID# Arguments:#   None#######################################functioncleanup(){…}######################################## Get configuration directory.# Globals:#   SOMEDIR# Arguments:#   None# Outputs:#   Writes location to stdout#######################################functionget_dir(){echo"${SOMEDIR}"}######################################## Delete a file in a sophisticated manner.# Arguments:#   File to delete, a path.# Returns:#   0 if thing was deleted, non-zero on error.#######################################functiondel_thing(){rm"$1"}
    section Implementation Comments
    Comment tricky, non-obvious, interesting or important parts of your code.
    This follows general Google coding comment practice. Don’t comment everything. If there’s a complex algorithm or you’re doing something out of the ordinary, put a short comment in.
    section TODO Comments
    Use TODO comments for code that is temporary, a short-term solution, or good-enough but not perfect.
    This matches the convention in theC++ Guide.
    TODOs should include the stringTODOin all caps, followed by the name, e-mail address, or other identifier of the person with the best context about the problem referenced by theTODO. The main purpose is to have a consistentTODOthat can be searched to find out how to get more details upon request. ATODOis not a commitment that the person referenced will fix the problem. Thus when you create aTODO, it is almost always your name that is given.
    Examples:
        code # TODO(mrmonkey): Handle the unlikely edge cases (bug ####)
  section Formatting
    While you should follow the style that’s already there for files that you’re modifying, the following are required for any new code.
    section Indentation
    Indent 2 spaces. No tabs.
    Use blank lines between blocks to improve readability. Indentation is two spaces. Whatever you do, don’t use tabs. For existing files, stay faithful to the existing indentation.
    Exception:The only exception for using tabs is for the body of<<-tab-indentedhere-document.
    section Line Length and Long Strings
    Maximum line length is 80 characters.
    If you have to write literal strings that are longer than 80 characters, this should be done with ahere documentor an embedded newline if possible.
    Words that are longer than 80 chars and can’t sensibly be split are ok, but where possible these items should be on a line of their own, or factored into a variable. Examples include file paths and URLs, particularly where string-matching them (such asgrep) is valuable for maintenance.
        code # DO use 'here document'scat<<ENDI am an exceptionally long string.END# Embedded newlines are ok toolong_string="I am an exceptionally long string."long_file="/i/am/an/exceptionally/loooooooooooooooooooooooooooooooooooooooooooooooooooong_file"long_string_with_long_file="i am including an exceptionally\/very/long/file\in this long string."# Long file converted into a shorter variable name with cleaner line breaking.long_string_alt="i am an including an exceptionally${long_file}in this long\string"
        code # Just because a line contains an exception doesn't mean the rest of the# line shouldn't be wrapped like usual.bad_long_string_with_long_file="i am including an exceptionally /very/long/file in this long string."
    section Pipelines
    Pipelines should be split one per line if they don’t all fit on one line.
    If a pipeline all fits on one line, it should be on one line.
    If not, it should be split at one pipe segment per line with the pipe on the newline and a 2 space indent for the next section of the pipe.\should be consistently used to indicate line continuation. This applies to a chain of commands combined using|as well as to logical compounds using||and&&.
        code # All fits on one linecommand1 | command2# Long commandscommand1\| command2\| command3\| command4
    This helps readability when distinguishing a pipeline from a regular long command continuation, particularly if the line is using both.
    Comments will need to precede the whole pipeline. If the comment and pipeline are large and complex, then it is worth considering moving low level details of them aside by using a helper function.
    section Control Flow
    Put; thenand; doon the same line as theif,for, orwhile.
    Control flow statements in shell are a bit different, but we follow the same principles as with braces when declaring functions. That is:; thenand; doshould be on the same line as theif/for/while/until/select.elseshould be on its own line and closing statements (fianddone) should be on their own line vertically aligned with the opening statement.
    Example:
        code # If inside a function remember to declare the loop variable as# a local to avoid it leaking into the global environment:local dirfordirin"${dirs_to_cleanup[@]}";do   if[[-d"${dir}/${SESSION_ID}"]];thenlog_date"Cleaning up old files in${dir}/${SESSION_ID}"rm"${dir}/${SESSION_ID}/"*||error_messageelsemkdir-p"${dir}/${SESSION_ID}"||error_messagefi done
    Although it is possible toomitin "$@"in for loops we recommend consistently including it for clarity.
        code in "$@"
        code forargin"$@";doecho"argument:${arg}"done
    section Case statement
      - Indent alternatives by 2 spaces.
      - A one-line alternative needs a space after the close parenthesis of the pattern and before the;;.
      - Long or multi-command alternatives should be split over multiple lines with the pattern, actions, and;;on separate lines.
    The matching expressions are indented one level from thecaseandesac. Multiline actions are indented another level. In general, there is no need to quote match expressions. Pattern expressions should not be preceded by an open parenthesis. Avoid the;&and;;&notations.
        code case"${expression}"ina)variable="…"some_command"${variable}""${other_expr}"…;;absolute)actions="relative"another_command"${actions}""${other_expr}"…;;*)error"Unexpected expression '${expression}'";;esac
    Simple commands may be put on the same line as the patternand;;as long as the expression remains readable. This is often appropriate for single-letter option processing. When the actions don’t fit on a single line, put the pattern on a line on its own, then the actions, then;;also on a line of its own. When on the same line as the actions, use a space after the close parenthesis of the pattern and another before the;;.
        code verbose='false'aflag=''bflag=''files=''whilegetopts'abf:v'flag;do   case"${flag}"ina)aflag='true';;b)bflag='true';;f)files="${OPTARG}";;v)verbose='true';;*)error"Unexpected option${flag}";;esacdone
    section Variable expansion
    In order of precedence: Stay consistent with what you find; quote your variables; prefer"${var}"over"$var".
    These are strongly recommended guidelines but not mandatory regulation. Nonetheless, the fact that it’s a recommendation and not mandatory doesn’t mean it should be taken lightly or downplayed.
    They are listed in order of precedence.
      - Stay consistent with what you find for existing code.
      - Quote variables, seeQuoting section below.
      - Don’t brace-delimit single character shell specials / positional parameters, unless strictly necessary or avoiding deep confusion.
    Prefer brace-delimiting all other variables.
        code # Section of *recommended* cases.# Preferred style for 'special' variables:echo"Positional:$1""$5""$3"echo"Specials: !=$!, -=$-, _=$_. ?=$?, #=$#*=$*@=$@\$=$$…"# Braces necessary:echo"many parameters:${10}"# Braces avoiding confusion:# Output is "a0b0c0"set--a b cecho"${1}0${2}0${3}0"# Preferred style for other variables:echo"PATH=${PATH}, PWD=${PWD}, mine=${some_var}"whileread-rf;doecho"file=${f}"done< <(find /tmp)
        code # Section of *discouraged* cases# Unquoted vars, unbraced vars, brace-delimited single letter# shell specials.echoa=$avar"b=$bvar""PID=${$}" "${1}"  # Confusing use: this is expanded as "${1}0${2}0${3}0", # not "${10}${20}${30}set -- a b c echo"$10$20$30"
    NOTE: Using braces in${var}isnota form of quoting. “Double quotes” must be usedas well.
    section Quoting
      - Always quote strings containing variables, command substitutions, spaces or shell meta characters, unless careful unquoted expansion is required or it’s a shell-internal integer (see next point).
      - Use arrays for safe quoting of lists of elements, especially command-line flags. SeeArraysbelow.
      - Optionally quote shell-internal, readonlyspecial variablesthat are defined to be integers:$?,$#,$$,$!. Prefer quoting of “named” internal integer variables, e.g. PPID etc for consistency.
      - Prefer quoting strings that are “words” (as opposed to command options or path names).
      - Be aware of the quoting rules for pattern matches in[[ … ]]. See theTest,[ … ], and[[ … ]]section below.
        code [ … ]
        code [[ … ]]
      - Use"$@"unless you have a specific reason to use$*, such as simply appending the arguments to a string in a message or log.
        code # 'Single' quotes indicate that no substitution is desired.# "Double" quotes indicate that substitution is required/tolerated.# Simple examples# "quote command substitutions"# Note that quotes nested inside "$()" don't need escaping.flag="$(some_command and its args"$@"'quoted separately')"# "quote variables"echo"${flag}"# Use arrays with quoted expansion for lists.declare-aFLAGSFLAGS=(--foo--bar='baz')readonlyFLAGS mybinary"${FLAGS[@]}"# It's ok to not quote internal integer variables.if(($#>3));thenecho"ppid=${PPID}"fi# "never quote literal integers"value=32# "quote command substitutions", even when you expect integersnumber="$(generate_number)"# "prefer quoting words", not compulsoryreadonlyUSE_INTEGER='true'# "quote shell meta characters"echo'Hello stranger, and well met. Earn lots of $$$'echo"Process$$: Done making\$\$\$."# "command options or path names"# ($1 is assumed to contain a value here)grep-liHugo /dev/null"$1"# Less simple examples# "quote variables, unless proven false": ccs might be emptygit send-email--to"${reviewers}"${ccs:+"--cc""${ccs}"}# Positional parameter precautions: $1 might be unset# Single quotes leave regex as-is.grep-cP'([Ss]pecial|\|?characters*)$'${1:+"$1"}# For passing on arguments,# "$@" is right almost every time, and# $* is wrong almost every time:## * $* and $@ will split on spaces, clobbering up arguments#   that contain spaces and dropping empty strings;# * "$@" will retain arguments as-is, so no args#   provided will result in no args being passed on;#   This is in most cases what you want to use for passing#   on arguments.# * "$*" expands to one argument, with all args joined#   by (usually) spaces,#   so no args provided will result in one empty string#   being passed on.## Consult# https://www.gnu.org/software/bash/manual/html_node/Special-Parameters.html and# https://mywiki.wooledge.org/BashGuide/Arrays for more(set--1"2 two""3 three tres";echo$#;set--"$*";echo"$#,$@")(set--1"2 two""3 three tres";echo$#;set--"$@";echo"$#,$@")
  section Features and Bugs
    section ShellCheck
    TheShellCheck projectidentifies common bugs and warnings for your shell scripts. It is recommended for all scripts, large or small.
    section Command Substitution
    Use$(command)instead of backticks.
    Nested backticks require escaping the inner ones with\. The$(command)format doesn’t change when nested and is easier to read.
    Example:
        code # This is preferred:var="$(command"$(command1)")"
        code # This is not:var="`command\`command1\``"
    section Test,[ … ], and[[ … ]]
    [[ … ]]is preferred over[ … ],testand/usr/bin/[.
    [[ … ]]reduces errors as no pathname expansion or word splitting takes place between[[and]]. In addition,[[ … ]]allows for pattern and regular expression matching, while[ … ]does not.
        code # This ensures the string on the left is made up of characters in# the alnum character class followed by the string name.# Note that the RHS should not be quoted here.if[["filename"=~ ^[[:alnum:]]+name]];thenecho"Match"fi# This matches the exact pattern "f*" (Does not match in this case)if[["filename"=="f*"]];thenecho"Match"fi
        code # This gives a "too many arguments" error as f* is expanded to the# contents of the current directory. It might also trigger the# "unexpected operator" error because `[` does not support `==`, only `=`.if["filename"==f*];thenecho"Match"fi
    For the gory details, see E14 in theBash FAQ
    section Testing Strings
    Use quotes rather than filler characters where possible.
    Bash is smart enough to deal with an empty string in a test. So, given that the code is much easier to read, use tests for empty/non-empty strings or empty strings rather than filler characters.
        code # Do this:if[["${my_var}"=="some_string"]];thendo_somethingfi# -z (string length is zero) and -n (string length is not zero) are# preferred over testing for an empty stringif[[-z"${my_var}"]];thendo_somethingfi# This is OK (ensure quotes on the empty side), but not preferred:if[["${my_var}"==""]];thendo_somethingfi
        code # Not this:if[["${my_var}X"=="some_stringX"]];thendo_somethingfi
    To avoid confusion about what you’re testing for, explicitly use-zor-n.
        code # Use thisif[[-n"${my_var}"]];thendo_somethingfi
        code # Instead of thisif[["${my_var}"]];thendo_somethingfi
    For clarity, use==for equality rather than=even though both work. The former encourages the use of[[and the latter can be confused with an assignment. However, be careful when using<and>in[[ … ]]which performs a lexicographical comparison. Use(( … ))or-ltand-gtfor numerical comparison.
        code # Use thisif[["${my_var}"=="val"]];thendo_somethingfi  if((my_var>3));thendo_somethingfi  if[["${my_var}"-gt3]];thendo_somethingfi
        code # Instead of thisif[["${my_var}"="val"]];thendo_somethingfi# Probably unintended lexicographical comparison.if[["${my_var}">3]];then# True for 4, false for 22.do_somethingfi
    section Wildcard Expansion of Filenames
    Use an explicit path when doing wildcard expansion of filenames.
    As filenames can begin with a-, it’s a lot safer to expand wildcards with./*instead of*.
        code # Here's the contents of the directory:# -f  -r  somedir  somefile# Incorrectly deletes almost everything in the directory by forcepsa@bilby$rm-v*removed directory:`somedir' removed `somefile'
        code # As opposed to:psa@bilby$rm-v./*removed`./-f' removed `./-r'rm: cannot remove`./somedir': Is a directory removed `./somefile'
    section Eval
    evalshould be avoided.
    Eval munges the input when used for assignment to variables and can set variables without making it possible to check what those variables were.
        code # What does this set?# Did it succeed? In part or whole?eval$(set_my_variables)# What happens if one of the returned values has a space in it?variable="$(evalsome_function)"
    section Arrays
    Bash arrays should be used to store lists of elements, to avoid quoting complications. This particularly applies to argument lists. Arrays should not be used to facilitate more complex data structures (seeWhen to use Shellabove).
    Arrays store an ordered collection of strings, and can be safely expanded into individual elements for a command or loop.
    Using a single string for multiple command arguments should be avoided, as it inevitably leads to authors usingevalor trying to nest quotes inside the string, which does not give reliable or readable results and leads to needless complexity.
        code # An array is assigned using parentheses, and can be appended to# with +=( … ).declare-aflagsflags=(--foo--bar='baz')flags+=(--greeting="Hello${name}")mybinary"${flags[@]}"
        code # Don’t use strings for sequences.flags='--foo --bar=baz'flags+=' --greeting="Hello world"'# This won’t work as intended.mybinary${flags}
        code # Command expansions return single strings, not arrays. Avoid# unquoted expansion in array assignments because it won’t# work correctly if the command output contains special# characters or whitespace.# This expands the listing output into a string, then does special keyword# expansion, and then whitespace splitting.  Only then is it turned into a# list of words.  The ls command may also change behavior based on the user's# active environment!declare-afiles=($(ls/directory))# The get_arguments writes everything to STDOUT, but then goes through the# same expansion process above before turning into a list of arguments.mybinary$(get_arguments)
      section Arrays Pros
      - Using Arrays allows lists of things without confusing quoting semantics. Conversely, not using arrays leads to misguided attempts to nest quoting inside a string.
      - Arrays make it possible to safely store sequences/lists of arbitrary strings, including strings containing whitespace.
      section Arrays Cons
    Using arrays can risk a script’s complexity growing.
      section Arrays Decision
    Arrays should be used to safely create and pass around lists. In particular, when building a set of command arguments, use arrays to avoid confusing quoting issues. Use quoted expansion –"${array[@]}"– to access arrays. However, if more advanced data manipulation is required, shell scripting should be avoided altogether; seeabove.
    section Pipes to While
    Use process substitution or thereadarraybuiltin (bash4+) in preference to piping towhile. Pipes create a subshell, so any variables modified within a pipeline do not propagate to the parent shell.
    The implicit subshell in a pipe towhilecan introduce subtle bugs that are hard to track down.
        code last_line='NULL'your_command |whileread-rline;do   if[[-n"${line}"]];thenlast_line="${line}"fi done# This will always output 'NULL'!echo"${last_line}"
    Using process substitution also creates a subshell. However, it allows redirecting from a subshell to awhilewithout putting thewhile(or any other command) in a subshell.
        code last_line='NULL'whilereadline;do   if[[-n"${line}"]];thenlast_line="${line}"fi done< <(your_command)# This will output the last non-empty line from your_commandecho"${last_line}"
    Alternatively, use thereadarraybuiltin to read the file into an array, then loop over the array’s contents. Notice that (for the same reason as above) you need to use a process substitution withreadarrayrather than a pipe, but with the advantage that the input generation for the loop is located before it, rather than after.
        code last_line='NULL'readarray-tlines < <(your_command)forlinein"${lines[@]}";do   if[[-n"${line}"]];thenlast_line="${line}"fi doneecho"${last_line}"
    Note: Be cautious using a for-loop to iterate over output, as infor var in $(...), as the output is split by whitespace, not by line. Sometimes you will know this is safe because the output can’t contain any unexpected whitespace, but where this isn’t obvious or doesn’t improve readability (such as a long command inside$(...)), awhile readloop orreadarrayis often safer and clearer.
    section Arithmetic
    Always use(( … ))or$(( … ))rather thanletor$[ … ]orexpr.
    Never use the$[ … ]syntax, theexprcommand, or theletbuilt-in.
    <and>don’t perform numerical comparison inside[[ … ]]expressions (they perform lexicographical comparisons instead; seeTesting Strings). For preference, don’t use[[ … ]]at allfor numeric comparisons, use(( … ))instead.
    It is recommended to avoid using(( … ))as a standalone statement, and otherwise be wary of its expression evaluating to zero
      - particularly withset -eenabled. For example,set -e; i=0; (( i++ ))will cause the shell to exit.
        code # Simple calculation used as text - note the use of $(( … )) within# a string.echo"$((2+2))is 4"# When performing arithmetic comparisons for testingif((a < b));then…fi# Some calculation assigned to a variable.((i=10*j + 400))
        code # This form is non-portable and deprecatedi=$[2*10]# Despite appearances, 'let' isn't one of the declarative keywords,# so unquoted assignments are subject to globbing wordsplitting.# For the sake of simplicity, avoid 'let' and use (( … ))leti="2 + 2"# The expr utility is an external program and not a shell builtin.i=$(expr4 + 4)# Quoting can be error prone when using expr too.i=$(expr4'*'4)
    Stylistic considerations aside, the shell’s built-in arithmetic is many times faster thanexpr.
    When using variables, the${var}(and$var) forms are not required within$(( … )). The shell knows to look upvarfor you, and omitting the${…}leads to cleaner code. This is slightly contrary to the previous rule about always using braces, so this is a recommendation only.
        code # N.B.: Remember to declare your variables as integers when# possible, and to prefer local variables over globals.local-ihundred="$((10*10))"declare-ifive="$((10/2))"# Increment the variable "i" by three.# Note that:#  - We do not write ${i} or $i.#  - We put a space after the (( and before the )).((i +=3))# To decrement the variable "i" by five:((i -=5))# Do some complicated computations.# Note that normal arithmetic operator precedence is observed.hr=2min=5sec=30echo"$((hr*3600+min*60+sec))"# prints 7530 as expected
  section Aliases
    Although commonly seen in.bashrcfiles, aliases should be avoided in scripts. As theBash manualnotes:
    For almost every purpose, shell functions are preferred over aliases.
    Aliases are cumbersome to work with because they require carefully quoting and escaping their contents, and mistakes can be hard to notice.
        code # this evaluates $RANDOM once when the alias is defined,# so the echo'ed string will be the same on each invocationaliasrandom_name="echo some_prefix_${RANDOM}"
    Functions provide a superset of alias’ functionality and should always be preferred. .
        code random_name(){echo"some_prefix_${RANDOM}"}# Note that unlike aliases function's arguments are accessed via $@fancy_ls(){ls-lh"$@"}
  section Naming Conventions
    section Function Names
    Lower-case, with underscores to separate words. Separate libraries with::. Parentheses are required after the function name. The keywordfunctionis optional, but must be used consistently throughout a project.
    If you’re writing single functions, use lowercase and separate words with underscore. If you’re writing a package, separate package names with::. However, functions intended for interactive use may choose to avoid colons as it can confuse bash auto-completion.
    Braces must be on the same line as the function name (as with other languages at Google) and no space between the function name and the parenthesis.
        code # Single functionmy_func(){…}# Part of a packagemypackage::my_func(){…}
    Thefunctionkeyword is extraneous when “()” is present after the function name, but enhances quick identification of functions.
    section Variable Names
    Same as for function names.
    Variables names for loops should be similarly named for any variable you’re looping through.
        code forzonein"${zones[@]}";dosomething_with"${zone}"done
    section Constants, Environment Variables, and readonly Variables
    Constants and anything exported to the environment should be capitalized, separated with underscores, and declared at the top of the file.
        code # ConstantreadonlyPATH_TO_FILES='/some/path'# Both constant and exported to the environmentdeclare-xrORACLE_SID='PROD'
    For the sake of clarityreadonlyorexportis recommended vs. the equivalentdeclarecommands. You can do one after the other, like:
        code # ConstantreadonlyPATH_TO_FILES='/some/path'exportPATH_TO_FILES
    It’s OK to set a constant at runtime or in a conditional, but it should be made readonly immediately afterwards.
        code ZIP_VERSION="$(dpkg--statuszip |sed-n's/^Version: //p')"if[[-z"${ZIP_VERSION}"]];thenZIP_VERSION="$(pacman-Q--infozip |sed-n's/^Version *: //p')"fi if[[-z"${ZIP_VERSION}"]];thenhandle_error_and_quitfireadonlyZIP_VERSION
    section Source Filenames
    Lowercase, with underscores to separate words if desired.
    This is for consistency with other code styles in Google:maketemplateormake_templatebut notmake-template.
    section Use Local Variables
    Declare function-specific variables withlocal.
    Ensure that local variables are only seen inside a function and its children by usinglocalwhen declaring them. This avoids polluting the global namespace and inadvertently setting variables that may have significance outside the function.
    Declaration and assignment must be separate statements when the assignment value is provided by a command substitution; as thelocalbuiltin does not propagate the exit code from the command substitution.
        code my_func2(){localname="$1"# Separate lines for declaration and assignment:localmy_varmy_var="$(my_func)"(($?==0))||return…}
        code my_func2(){# DO NOT do this:# $? will always be zero, as it contains the exit code of 'local', not my_funclocalmy_var="$(my_func)"(($?==0))||return…}
    section Function Location
    Put all functions together in the file just below constants. Don’t hide executable code between functions. Doing so makes the code difficult to follow and results in nasty surprises when debugging.
    If you’ve got functions, put them all together near the top of the file. Only includes,setstatements and setting constants may be done before declaring functions.
    section main
    A function calledmainis required for scripts long enough to contain at least one other function.
    In order to easily find the start of the program, put the main program in a function calledmainas the bottom-most function. This provides consistency with the rest of the code base as well as allowing you to define more variables aslocal(which can’t be done if the main code is not a function). The last non-comment line in the file should be a call tomain:
        code main"$@"
    Obviously, for short scripts where it’s just a linear flow,mainis overkill and so is not required.
  section Calling Commands
    section Checking Return Values
    Always check return values and give informative return values.
    For unpiped commands, use$?or check directly via anifstatement to keep it simple.
    Example:
        code if!mv"${file_list[@]}""${dest_dir}/";thenecho"Unable to move${file_list[*]}to${dest_dir}">&2exit1fi# Ormv"${file_list[@]}""${dest_dir}/"if(($?!=0));thenecho"Unable to move${file_list[*]}to${dest_dir}">&2exit1fi
    Bash also has thePIPESTATUSvariable that allows checking of the return code from all parts of a pipe. If it’s only necessary to check success or failure of the whole pipe, then the following is acceptable:
        code tar-cf- ./*|(cd"${dir}"&&tar-xf-)if((PIPESTATUS[0]!=0||PIPESTATUS[1]!=0));thenecho"Unable to tar files to${dir}">&2fi
    However, asPIPESTATUSwill be overwritten as soon as you do any other command, if you need to act differently on errors based on where it happened in the pipe, you’ll need to assignPIPESTATUSto another variable immediately after running the command (don’t forget that[is a command and will wipe outPIPESTATUS).
        code tar-cf- ./*|(cd"${DIR}"&&tar-xf-)return_codes=("${PIPESTATUS[@]}")if((return_codes[0]!=0));thendo_somethingfi if((return_codes[1]!=0));thendo_something_elsefi
    section Builtin Commands vs. External Commands
    Given the choice between invoking a shell builtin and invoking a separate process, choose the builtin.
    We prefer the use of builtins such as theParameter Expansionfunctionality provided bybashas it’s more efficient, robust, and portable (especially when compared to things likesed). See also the=~operator.
        code =~
    Examples:
        code # Prefer this:addition="$((X+Y))"substitution="${string/#foo/bar}"if[["${string}"=~ foo:(\d+)]];thenextraction="${BASH_REMATCH[1]}"fi
        code # Instead of this:addition="$(expr"${X}"+"${Y}")"substitution="$(echo"${string}"|sed-e's/^foo/bar/')"extraction="$(echo"${string}"|sed-e's/foo:\([0-9]\)/\1/')"
  section When in Doubt: Be Consistent
    Using one style consistently through our codebase lets us focus on other (more important) issues. Consistency also allows for automation. In many cases, rules that are attributed to “Be Consistent” boil down to “Just pick one and stop worrying about it”; the potential value of allowing flexibility on these points is outweighed by the cost of having people argue over them.
    However, there are limits to consistency. It is a good tie breaker when there is no clear technical argument, nor a long-term direction. Consistency should not generally be used as a justification to do things in an old style without considering the benefits of the new style, or the tendency of the codebase to converge on newer styles over time.